/**
  * Apache License
  * Version 2.0, January 2004
  * http://www.apache.org/licenses/
  */

package echoes

/**
  * Tokens generated by lexer. The derived classes are designed similar to those in LLVM.
  */
sealed abstract class Token {
  /**
    * Print strings of tokens for debuging
    *
    * @return the string of the given token
    */
  def dbgString: String = this match {
    case Identifier(name) => s"ID($name)"
    case Keyword(name) => s"KEYWORD($name)"
    case Literal(value) => s"LIT($value)"
    case Punctuation(op) => s"PUNC($op)"
  }
}


final case class Punctuation(op: Char) extends Token
object Punctuation {
  val punctuations = List('=', '{', '}', '(', ')', '>', '<', '=', ';')

  def isPunctuation(ch: Char) = punctuations.contains(ch)
}

final case class Keyword(name: String) extends Token
object Keyword {
  val keywords = List("lambda", "if", "else", "bool", "int")

  def isKeyword(str: String) = keywords.contains(str)
}

final case class Identifier(name: String) extends Token
final case class Literal(value: LiteralValue) extends Token

sealed abstract class LiteralValue
final case class IntLiteral(value: Int) extends LiteralValue {
  override def toString(): String = value.toString()
}

object IntLiteral {
  def isNumber(ch: Char) = "1234567890".contains(ch)
}

final case class BoolLiteral(value: Boolean) extends LiteralValue {
  override def toString(): String = value.toString()
}

object BoolLiteral {
  def isBool(str: String) = str.equals("true") || str.equals("false")
}
